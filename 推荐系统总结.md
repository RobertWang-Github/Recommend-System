简单来说,推荐是个分类问题,待推荐的对象item和人person之间构成特征二元组(item_i,person_i),而click与否则是标签(c_i).  
然而,如果考虑到click和order的差异,我们需要最大化  
<a href="https://www.codecogs.com/eqnedit.php?latex=income&space;=&space;P(click|impression)*P(order|click)*price" target="_blank"><img src="https://latex.codecogs.com/gif.latex?income&space;=&space;P(click|impression)*P(order|click)*price" title="income = P(click|impression)*P(order|click)*price" /></a>  
impression(曝光)->click(点击)->order(实现) * price(价格) 才是我们需要的收益.

下面对几个的推荐系统作总结:  


1.FM(Factorization Machines 因子分解机)  
&emsp;&emsp;1.线性部分(将各特征线性加权,显然线性部分直接用sigmoid激活就是LR)  
&emsp;&emsp;&emsp;&emsp;<a href="https://www.codecogs.com/eqnedit.php?latex=y_linear&space;=&space;\sigma(<\overrightarrow{w},\overrightarrow{x}>))" target="_blank"><img src="https://latex.codecogs.com/gif.latex?y_linear&space;=&space;<\overrightarrow{w},\overrightarrow{x}>" title="y_linear = <\overrightarrow{w},\overrightarrow{x}>" /></a>  
&emsp;&emsp;2.二阶部分(各特征两两组合(此处以乘积形式))  
&emsp;&emsp;&emsp;&emsp;<a href="https://www.codecogs.com/eqnedit.php?latex=y_{2d-polynomial}&space;=&space;\overrightarrow{x}^T*W^{(2)}*\overrightarrow{x}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?y_{2d-polynomial}&space;=&space;\overrightarrow{x}^T*W^{(2)}*\overrightarrow{x}" title="y_{2d-polynomial} = \overrightarrow{x}^T*W^{(2)}*\overrightarrow{x}" /></a>  
&emsp;&emsp;&emsp;&emsp;<img src="https://latex.codecogs.com/gif.latex?W^{(2)}" title="W^{(2)}" /></a>是一个对称阵,因为任何两个特征x_i和x_j的关系是对称的.  




&emsp;&emsp;3.输出部分(采用sigmoid作为激活函数)  
&emsp;&emsp;&emsp;&emsp;  

2.FFM  




3.DeepFM  










0.标签匹配(此时就不得不介绍下本人的原创方法)  
&emsp;&emsp;1.给item打上标签,此时每个类下的标签都会有一个经验分布(由频数或者分数归一化得到).具体哪些标签算作一类要由规则确定.假如是类为行业关键词,那么这些词就构成了这个类下的标签.
&emsp;&emsp;2.搜集用户person在item上的信息(即将每个用户在过去某个时间段内浏览的item的标签分类汇总,拿到每个类下标签的经验分布)  
&emsp;&emsp;3.依据person的各类下的概率分布和item的各类下的概率分布,按item标签的来源基于不同权重,各类予以不同权重,类内采用命中标签的概率值相乘的方式获取分数,再将该分数和类与来源的权重层层加权,最后将总分数排序,作为推荐候选名单.  
&emsp;&emsp;4.也可以将person和item的概率分布计算交叉熵作为分数进行加权.  
&emsp;&emsp;5.也可以将person和item的概率分布作为特征传入分类算法.  



草稿
&emsp;&emsp;<a href="https://www.codecogs.com/eqnedit.php?latex=y_{2d-ploynomial}&space;=&space;\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}*x_i*x_j" target="_blank"><img src="https://latex.codecogs.com/gif.latex?y_{2d-ploynomial}&space;=&space;\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}*x_i*x_j" title="y_{2d-ploynomial} = \sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}*x_i*x_j" /></a>  
&emsp;&emsp;w_ij为矩阵W的元素,W必须为n阶对称阵,可以将其因子分解(FM因此得名)为 W =  WS^T * WS, WS为n * k的矩阵,k为因子维度.<a href="https://www.codecogs.com/eqnedit.php?latex=w_{ij}&space;=&space;<\overrightarrow{v_i},\overrightarrow{v_j}>" target="_blank"><img src="https://latex.codecogs.com/gif.latex?w_{ij}&space;=&space;<\overrightarrow{v_i},\overrightarrow{v_j}>" title="w_{ij} = <\overrightarrow{v_i},\overrightarrow{v_j}>" /></a>  
&emsp;&emsp;其中,v_i与v_j为矩阵WS的列向量.

